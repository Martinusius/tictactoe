var $=Object.defineProperty;var x=(t,n,r)=>n in t?$(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r;var h=(t,n,r)=>(x(t,typeof n!="symbol"?n+"":n,r),r);(function(t,n){typeof exports=="object"&&typeof module!="undefined"?module.exports=n():typeof define=="function"&&define.amd?define(n):(t=typeof globalThis!="undefined"?globalThis:t||self,t.tictactoe=n())})(this,function(){"use strict";class t{constructor(){h(this,"_board",{});h(this,"_bounds",{minX:0,maxX:2,minY:0,maxY:2});h(this,"_winCallbacks",[]);h(this,"_drawCallbacks",[]);h(this,"_goal",3);h(this,"_fillPosition",{x:0,y:0});h(this,"gameOver",!1);h(this,"boundingBox",null)}_checkWinner(i,o,e){const s=(a,c)=>{let u=i,d=o,l=0;for(;this._board[`${u},${d}`]===e;)u+=a,d+=c,l++;return l},_=s(1,0)+s(-1,0)-1,b=s(0,1)+s(0,-1)-1,m=s(1,1)+s(-1,-1)-1,f=s(1,-1)+s(-1,1)-1;Math.max(_,b,m,f)>=this._goal&&(this.gameOver=!0,this._winCallbacks.forEach(a=>a(e)))}_moveFill(){if(!(!this._bounds||this.gameOver))for(;this._board[`${this._fillPosition.x},${this._fillPosition.y}`]!==void 0;){if(this._fillPosition.x===this._bounds.maxX){if(this._fillPosition.y===this._bounds.maxY){this.gameOver=!0,this._drawCallbacks.forEach(i=>i());return}this._fillPosition.x=this._bounds.minX,this._fillPosition.y++;continue}this._fillPosition.x++}}bounds(i,o,e,s){if(i>e||o>s)throw new Error(`Invalid bounds: ${i}, ${o}, ${e}, ${s}`);return this._bounds={minX:i,minY:o,maxX:e,maxY:s},this._fillPosition={x:i,y:o},this}size(i,o=i){if(i<=0||o<=0)throw new Error(`Invalid size (not positive): ${i}, ${o}`);return this._bounds={minX:0,minY:0,maxX:i-1,maxY:o-1},this._fillPosition={x:0,y:0},this}infinite(){return this._bounds=null,this}goal(i){if(i<=0)throw new Error(`Invalid goal (not positive): ${i}`);return this._goal=i,this}move(i,o,e){if(this.gameOver)throw new Error("Cannot move: This game is already over");if(typeof e!="string")throw new Error("The move has to be a string");if(this._bounds&&(this._bounds.minX>i||this._bounds.maxX<i||this._bounds.minY>o||this._bounds.maxY<o))throw new Error(`Move out of bounds: (Move: ${i}, ${o}, Bounds: ${this._bounds.minX}, ${this._bounds.minY}, ${this._bounds.maxX}, ${this._bounds.maxY})`);if(this._board[`${i},${o}`]!==void 0)throw new Error("Cannot move: Position is already taken");return this.boundingBox?this.boundingBox={minX:Math.min(this.boundingBox.minX,i),minY:Math.min(this.boundingBox.minY,o),maxX:Math.max(this.boundingBox.maxX,i),maxY:Math.max(this.boundingBox.maxY,o)}:this.boundingBox={minX:i,minY:o,maxX:i,maxY:o},this._board[`${i},${o}`]=e,this._checkWinner(i,o,e),this._moveFill(),this}on(i,o){i==="draw"?this._drawCallbacks.push(o):i==="win"&&this._winCallbacks.push(o)}get(i,o){if(this._bounds&&(this._bounds.minX>i||this._bounds.maxX<i||this._bounds.minY>o||this._bounds.maxY<o))throw new Error(`Get out of bounds: (Get: ${i}, ${o}, Bounds: ${this._bounds.minX}, ${this._bounds.minY}, ${this._bounds.maxX}, ${this._bounds.maxY})`);return this._board[`${i},${o}`]||null}reset(){this.gameOver=!1,this._fillPosition={x:0,y:0},this._board={}}}function n(){return new t}return n});
