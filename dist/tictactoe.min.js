var f=Object.defineProperty;var c=(o,s,a)=>s in o?f(o,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):o[s]=a;var e=(o,s,a)=>(c(o,typeof s!="symbol"?s+"":s,a),a);(function(o,s){typeof exports=="object"&&typeof module!="undefined"?module.exports=s():typeof define=="function"&&define.amd?define(s):(o=typeof globalThis!="undefined"?globalThis:o||self,o.tictactoe=s())})(this,function(){"use strict";class o{constructor(){e(this,"_board",{});e(this,"_bounds",{minX:0,maxX:2,minY:0,maxY:2});e(this,"_winCallbacks",[]);e(this,"_drawCallbacks",[]);e(this,"_goal",3);e(this,"_fillPosition",{x:0,y:0});e(this,"boundingBox",null);e(this,"gameOver",!1);e(this,"winner",null);e(this,"goalPath",null)}_checkWinner(i,n,h){const t=(r,_)=>{let l=i+r,d=n+_;const b=[];for(;this._board[`${l},${d}`]===h;)b.push({x:l,y:d}),l+=r,d+=_;return b},m=[[...t(1,0),...t(-1,0)],[...t(0,1),...t(0,-1)],[...t(1,1),...t(-1,-1)],[...t(1,-1),...t(-1,1)]],u=[{x:i,y:n}];m.forEach(r=>{r.length+1>=this._goal&&u.push(...r)}),u.length>1&&(this.gameOver=!0,this.winner=h,this.goalPath=u,this._winCallbacks.forEach(r=>r(h,u)))}_moveFill(){if(!(!this._bounds||this.gameOver))for(;this._board[`${this._fillPosition.x},${this._fillPosition.y}`]!==void 0;){if(this._fillPosition.x===this._bounds.maxX){if(this._fillPosition.y===this._bounds.maxY){this.gameOver=!0,this._drawCallbacks.forEach(i=>i());return}this._fillPosition.x=this._bounds.minX,this._fillPosition.y++;continue}this._fillPosition.x++}}bounds(i,n,h,t){if(i>h||n>t)throw new Error(`Invalid bounds: ${i}, ${n}, ${h}, ${t}`);return this._bounds={minX:i,minY:n,maxX:h,maxY:t},this._fillPosition={x:i,y:n},this}size(i,n=i){if(i<=0||n<=0)throw new Error(`Invalid size (not positive): ${i}, ${n}`);return this._bounds={minX:0,minY:0,maxX:i-1,maxY:n-1},this._fillPosition={x:0,y:0},this}infinite(){return this._bounds=null,this}goal(i){if(i<=0)throw new Error(`Invalid goal (not positive): ${i}`);return this._goal=i,this}move(i,n,h){if(this.gameOver)throw new Error("Cannot move: This game is already over");if(typeof h!="string")throw new Error("The move has to be a string");if(this._bounds&&(this._bounds.minX>i||this._bounds.maxX<i||this._bounds.minY>n||this._bounds.maxY<n))throw new Error(`Move out of bounds: (Move: ${i}, ${n}, Bounds: ${this._bounds.minX}, ${this._bounds.minY}, ${this._bounds.maxX}, ${this._bounds.maxY})`);if(this._board[`${i},${n}`]!==void 0)throw new Error("Cannot move: Position is already taken");return this.boundingBox?this.boundingBox={minX:Math.min(this.boundingBox.minX,i),minY:Math.min(this.boundingBox.minY,n),maxX:Math.max(this.boundingBox.maxX,i),maxY:Math.max(this.boundingBox.maxY,n)}:this.boundingBox={minX:i,minY:n,maxX:i,maxY:n},this._board[`${i},${n}`]=h,this._checkWinner(i,n,h),this._moveFill(),this}on(i,n){i==="draw"?this._drawCallbacks.push(n):i==="win"&&this._winCallbacks.push(n)}get(i,n){if(this._bounds&&(this._bounds.minX>i||this._bounds.maxX<i||this._bounds.minY>n||this._bounds.maxY<n))throw new Error(`Get out of bounds: (Get: ${i}, ${n}, Bounds: ${this._bounds.minX}, ${this._bounds.minY}, ${this._bounds.maxX}, ${this._bounds.maxY})`);return this._board[`${i},${n}`]||null}reset(){this.gameOver=!1,this.winner=null,this.goalPath=null,this._fillPosition={x:0,y:0},this._board={}}}function s(){return new o}return s});
